#!/usr/bin/env bash

dna-setup_backup_restore() {

	mkdir -p $conf_backups_local_dir

	echo "${b-}$project_name performs nightly backups and stores them locally for safekeeping.${x-}"
	echo

	echo "${b-}By default $project_name stores local backups in the | ${g-}$install_dir/backups${x-}${b-} | directory.${x-}"
	echo
	echo "${b-}If and only if your machine doesn't have sufficient local storage space available, you may specify another location.${x-}"
	echo
	echo "${b-}Bare in mind this location is intented to store local backups in real time as they're being produced, and therefore must always be directly accessible to $project_name at the filesystem level.${x-}"
	echo
	echo "${b-}If you decide not to use the default location, be sure so specify a highly available and high performance location.${x-}"
	echo
	echo "${b-}Do not use a custom location for backup security / resilience purposes, but rather only if your machine has storage space limitations.${x-}"
	echo
	echo "${b-}$project_name already has a built-in S3 backup archival function, which you can set up in a few steps after this one independently of this setting, and which easily supports low performance and low bandwith destinations.${x-}"
	echo

	### If option "backup_local_storage_location" is set and is currently "default", delete the "backup_local_storage_path" option to start fresh

	if [ -f "$conf_backups_local_dir/backup_local_storage_location" ]
	then
		if [[ $(< "$conf_backups_local_dir/backup_local_storage_location") = "default" ]]
		then
			if [ -f "$conf_backups_local_dir/backup_local_storage_path" ]
			then
				rm "$conf_backups_local_dir/backup_local_storage_path"
			fi
		fi
	fi

	describe_setting() {

		echo "${b-}Please set your local backup storage location [default/custom]:${x-}"
		echo

	}

	validate_input() {

		case $input in
			default)	backup_local_storage_location=default
			valid=y
			;;
			custom)		backup_local_storage_location=custom
			valid=y
			;;
			*)	echo "${r-}${b-}Invalid setting for | backup_local_storage_location | in function | ${FUNCNAME[0]} |.${x-}"
			echo
			valid=n
			;;
		esac

	}

	dna-set_option -o backup_local_storage_location -v y -d y -p backups/local

	if [ $backup_local_storage_location = "default" ]
    then

		backup_local_storage_path="$install_dir/backups"
		touch "$conf_backups_local_dir/backup_local_storage_path"
		echo "$install_dir/backups" > "$conf_backups_local_dir/backup_local_storage_path"

	else

		describe_setting() {

			echo "${b-}Please specify your custom backup local storage location [i.e. /mnt/network-volume/raptor-backups/]:${x-}"
			echo

		}

		validate_input() {

			if [ -d $input ]
			then
				echo "${g-}${b-}Location found and valid.${x-}"
				echo
				valid=y
			else
				echo "${r-}${b-}Location not found.${x-}"
				echo
				echo "${b-}Ensure the path is valid and try again.${x-}"
				echo
				valid=n
			fi

		}

		dna-set_option -o backup_local_storage_path -v y -d y -p backups/local

    fi

	describe_setting() {

		echo "${b-}Please choose your backup compression type [bz2/none]:${x-}"
		echo

	}

	validate_input() {

		case $input in
			bz2)	backup_compression_type=bz2
			valid=y
			;;
			none)	backup_compression_type=none
			valid=y
			;;
			*)	echo "${r-}${b-}Invalid setting for | backup_type | in function | ${FUNCNAME[0]} |.${x-}"
			echo
			valid=n
			;;
		esac

	}

	dna-set_option -o backup_compression_type -v y -d y -p backups/local

	describe_setting() {

		echo "${b-}Please set how many backups should be kept locally at the very minimum [suggested between 3 and 7].${x-}"
		echo

	}

	dna-set_option -o min_local_backups -v n -d y -p backups/local


	describe_setting() {

		echo "${b-}Please set the maximum number of backups that should be kept locally [suggested between 8 and 42].${x-}"
		echo

	}

	dna-set_option -o max_local_backups -v n -d y -p backups/local


	describe_setting() {

		echo "${b-}Please set the maximum space that local archives storage should occupy in MB [suggested between 1000 and 8000].${x-}"
		echo

	}

	dna-set_option -o max_local_storage -v n -d y -p backups/local


	describe_setting() {

		echo "${b-}$project_name can store your backups on an S3 storage server for safe, offsite recovery in case of need.${x-}"
		echo
		echo "${b-}Now specify your desired backup storage location [local/s3]:${x-}"
		echo

	}

	validate_input() {

		case $input in
			local)	backup_archival_location=local
			valid=y
			;;
			s3)		backup_archival_location=s3
			valid=y
			;;
			*)	echo "${r-}${b-}Invalid setting for | backup_type | in function | ${FUNCNAME[0]} |.${x-}"
			echo
			valid=n
			;;
		esac

	}

	dna-set_option -o backup_archival_location -v y -d y -p backups


	if [ $backup_archival_location = "s3" ]
	then

		if [ ! "${previous_value_outcome-null}" = "kept" ]
		then

			read -rp "${b-}Do you have an S3 file storage server already set up? (Y/n): ${x-}" -n 1
			echo

			if [[ ! $REPLY =~ ^[Nn]$ ]]
			then

				echo "${b-}Ok, so let's set up your S3 file storage server settings now.${x-}"
				echo
				s3_continue_setup=y

			else

				echo
				echo "${b-}No problem, follow this guide [link will be published here soon] to configure your S3 file storage server.${x-}"
				echo
				echo "${b-}Keeping backups local for now [simply re-run this installation when you're ready to upgrade your backups to S3 enabled].${x-}"
				echo

				backup_archival_location=local
				echo "local" > $conf_dir/backup_archival_location

				read -rp "${b-}[press enter to continue reading...]${x-}"

			fi

		else

			s3_continue_setup=y

		fi

		if [ "${s3_continue_setup-null}" = "y" ]
		then

			dna-setup_backup_restore_s3

			### Check that the user has actually completed and confirmed S3 connection

			if [ "${backup_archival_location}" = "s3" ]
			then

				describe_setting() {

					echo "${b-}Please set your desired minimum backup history interval to keep on S3.${x-}"
					echo
					echo "${b-}Indicate an interval, which is a number followed by one of the characters D, W, M, or Y (indicating days, weeks, months, or years respectively).${x-}"
					echo

				}

				dna-set_option -o duplicity_min_history -v n -d y -p backups/s3

				describe_setting() {

					echo "${b-}Also upload a full backup archive file to S3 on the first of the month? [y/n]${x-}"
					echo

				}

				validate_input() {

					case $input in
						y)	s3_monthly_uploads=y
						valid=y
						;;
						n)	s3_monthly_uploads=s3
						valid=y
						;;
						*)	echo "${r-}${b-}Invalid setting for | s3_monthly_uploads | in function | ${FUNCNAME[0]} |.${x-}"
						echo
						valid=n
						;;
					esac

				}

				dna-set_option -o s3_monthly_uploads -v y -d y -p backups/s3

			fi

		fi

	else

		echo "${b-}Ok, keeping backups local. Remember to periodically copy your backups from the backups directory over to your backup storage machine!${x-}"
		echo

		read -rp "${b-}[press enter to continue reading...]${x-}"

	fi

	clear

}

dna-setup_backup_restore_s3() {

	while getopts ":s" arguments; do
		case $arguments in
			s)	skip_questions=y
			;;
			\?)	echo "${r-}${b-}Invalid option | -$OPTARG | for function | ${FUNCNAME[0]} |.${x-}"
			echo
			dna-exit
			;;
		esac
	done
    OPTIND=1

	dna-install_duplicity
	dna-install_dependencies -p "s3cmd"

	mkdir -p "$conf_backups_s3_dir"

	if [ -z ${skip_questions-} ]
	then

		echo "${r-}${b-}If you're setting up this machine to restore a previous $project_name installation from another machine, you must specify so now.${x-}"
		echo
		echo "${b-}Selecting yes at the next prompt will block ALL backups to S3 to avoid overwriting previous valid backups on S3 and give you a chance to restore them on this machine.${x-}"
		echo
		echo "${r-}${b-}If you choose yes, make sure NOT to use this instance as it is [as it will NOT be backed up on S3] but rather remember to perform the restore right after you're finished running this install script.${x-}"
		echo
		read -rp "${b-}Are you setting up this machine to restore a previous $project_name installation from another machine? (y/N): ${x-}" -n 1
		echo

		if [[ $REPLY =~ ^[Yy]$ ]]
		then

			echo
			echo "${r-}${b-}Ok, blocking ALL backups to S3 until a restore is performed. Do so right after you're finished running this install script.${x-}"
			echo

			restore_intent=y
			touch "$conf_backups_s3_dir/block_s3_backups"

			echo "${b-}If you intend to restore from S3 you must have your encryption passphrase handy now as you were reminded upon initial installation on your old machine.${x-}"
			echo
			read -rp "${b-}Do you have your S3 encryption passphrase ready to specify now? (Y/n): ${x-}" -n 1
			echo

			if [[ ! $REPLY =~ ^[Nn]$ ]]
			then

				describe_setting() {

					echo "${b-}Now specify your previous S3 encryption passphrase here to decrypt your existing S3 backups:${x-}"
					echo

				}

				if [ -f "$conf_backups_s3_dir/backups_passphrase" ]
				then
					mv "$conf_backups_s3_dir/backups_passphrase" "$conf_backups_s3_dir/backups_passphrase_old"
				fi

				dna-set_option -o backups_passphrase -v n -d y -p backups/s3

			else

				echo
				echo "${b-}Ok, blocking S3 restores until you manually specify your old S3 backups encryption passphrase here:${x-}"
				echo
				echo "${b-} | $conf_backups_s3_dir/backups_passphrase | ${x-}"
				echo
				echo "${b-}If you've lost your encryption passphrase, your S3 backups are also lost. Look for a local backup you might have from your old machine to restore your previous instance.${x-}"
				echo
				touch $conf_backups_s3_dir/block_s3_restores

			fi

		else

			echo "${b-}NOT selected restore mode, ${g-}will allow S3 backups${x-}${b-}..."
			echo

			backups_passphrase_conf_path="$conf_backups_s3_dir/backups_passphrase"
			backups_passphrase="$(cat $backups_passphrase_conf_path 2> /dev/null || true)"

			if [ -z "${backups_passphrase}" ];
			then
				touch "$backups_passphrase_conf_path"
				chmod 700 "$backups_passphrase_conf_path"
				generated_passphrase="$(pwgen 42 1)"
				echo "$generated_passphrase" > "$backups_passphrase_conf_path"
			else
				chmod 700 "$backups_passphrase_conf_path" # In case someone accidentally modified permissions on $conf_backups_s3_dir
			fi

			backups_passphrase="$(cat $backups_passphrase_conf_path)"

			dna-echo -m "Your S3 backups encryption passphrase is:"
			dna-echo -m " | ${l-}${backups_passphrase}${n-} | "
			dna-echo -m "Make sure you keep it saved in a safe location OUTSIDE of this machine and NOT on the S3 file storage server."
			dna-echo -e "You will NOT be able to restore ANY backup without this passphrase."
			dna-echo -m "This is your only chance to save this passphrase. If you don't do it now and this machine's data is lost, so will be your backups."
			dna-press_to_continue

		fi

	else

		describe_setting() {

			echo "${b-}Now specify your previous S3 encryption passphrase here to decrypt your existing S3 backups:${x-}"
			echo

		}

		if [ -f "$conf_backups_s3_dir/backups_passphrase" ]
		then
			mv "$conf_backups_s3_dir/backups_passphrase" "$conf_backups_s3_dir/backups_passphrase_old"
		fi

		dna-set_option -o backups_passphrase -v n -d y -p backups/s3

	fi

	until [ ${s3_setup_accepted-null} = "y" ]
	do

		declare -A s3_options_array=(
			[s3_access_key_id]="AWS Access Key ID"
			[s3_secret_access_key]="AWS Secret Access Key"
			[s3_endpoint]="S3 Endpoint URL"
			[s3_bucket_name]="S3 Bucket Name"
		)

		for i in "${!s3_options_array[@]}"
		do

			describe_setting() {

				echo "${b-}Now set your ${s3_options_array[$i]}.${x-}"
				echo

			}

			dna-set_option -o "$i" -v n -d y -p backups/s3

		done

		echo "----------------"
		echo
		echo "${b-}To make sure everything is correct:${x-}"
		echo
		echo "1] Your ${b-}AWS Access Key ID${x-} will be:"
		echo
		echo "${b-} | ${g-}$s3_access_key_id${x-}${b-} | ${x-}"
		echo
		echo "2] Your ${b-}AWS Secret Access Key${x-} will be:"
		echo
		echo "${b-} | ${g-}$s3_secret_access_key${x-}${b-} | ${x-}"
		echo
		echo "3] Your ${b-}S3 Endpoint URL${x-} will be:"
		echo
		echo "${b-} | ${g-}$s3_endpoint${x-}${b-} | ${x-}"
		echo
		echo "4] Your ${b-}S3 Bucket Name${x-} will be:"
		echo
		echo "${b-} | ${g-}$s3_bucket_name${x-}${b-} | ${x-}"
		echo
		echo "----------------"
		echo

		read -rp "${b-}Does everything look all right? (Y/n): ${x-}" -n 1
		echo
		if [[ ! $REPLY =~ ^[Nn]$ ]]
		then

			echo "${b-}Ok, proceeding to check S3 connection details${x-}."
			echo

			### Check S3 connection

			s3cmd --configure --access_key="$s3_access_key_id" --secret_key="$s3_secret_access_key" --host="$s3_endpoint" --host-bucket="%(bucket).$s3_endpoint" -s --no-encrypt --dump-config 2>&1 | tee /root/.s3cfg &> /dev/null
			set +e
			s3cmd info s3://"$s3_bucket_name" >/dev/null 2>&1

			if [[ $? -eq 0 ]]; then
				echo "${g-}${b-}S3 connection details appear to be valid.${x-}"
				echo
				s3_setup_accepted=y
				sleep 1
			else
				echo "${r-}${b-}S3 connection details do NOT appear to be valid.${x-}"
				echo
				read -rp "${b-}Would you like to try setting it up again? (Y/n): ${x-}" -n 1
				echo
				if [[ ! $REPLY =~ ^[Nn]$ ]]
				then
					s3_setup_accepted=n
					echo "${b-}Ok, repeating S3 setup...${x-}"
					echo
				else
					s3_setup_accepted=y
					echo
					echo "${b-}Ok, skipping S3 setup and REMOVING S3 setting from $project_name...${x-}"
					echo
					backup_archival_location=local
					echo "local" > $conf_backup_dir/backup_archival_location
					read -rp "${b-}[press enter to continue reading...]${x-}"
				fi
			fi
			set -e

		else
			s3_setup_accepted=n
			echo
			echo "${b-}Ok, repeating S3 setup...${x-}"
			echo
		fi

	done

	unset skip_questions

}

dna-backup_update_storage_info() {

	### fetch system / existing locally stored data.

	free_disk_space="$(df -m --output=avail "$backup_local_storage_path" | xargs | sed -e 's/Avail //g')"

	local_archive_items="$(ls -1q $backup_local_storage_path/archive | wc -l)"
	local_archive_size="$(du -sm $backup_local_storage_path/archive | xargs | sed "s|${backup_local_storage_path}/archive||g" | xargs)"

	### calculate upcoming backup size estimate.

	synthia-calculate_backup_size

}

dna-backup_purge_backups() {

	## purge backups older than the latest $max_local_backups.

	local_archive_items="$(ls -1q ${backup_local_storage_path}/archive | wc -l)"

	if [ "${local_archive_items}" -gt "${max_local_backups}" ]
	then

		tail_number=$(( "${max_local_backups}" + 1 ))

		( cd "${backup_local_storage_path}/archive" && ls -t | tail -n +"${tail_number}" | xargs -d '\n' rm )

		dna-backup_update_storage_info

	fi

	dna-echo -m "You have: | ${o-}${local_archive_items}${n-} | local backups occupying: | ${y-}${local_archive_size} MB${n-} | of space."

	if [ "${local_archive_size}" -gt "${max_local_storage}" ]
	then

		dna-echo -e "Local archive size: [ ${n-}${local_archive_size} MB${r-} ] larger than: | ${n-}max_local_storage${r-} | setting [ ${n-}${max_local_storage} MB${r-} ]."

		dna-echo_operation -h "purging old backups while respecting your specified number of minimum backups to keep"

		error_description="to stay below the: | ${n-}max_local_storage${r-} | setting you chose"

		counter="${max_local_backups}"

		while [ "${local_archive_size}" -gt "${max_local_storage}" ]
		do

			dna-backup_purge_loop

		done

		dna-echo -s "Local archive size now low enough: [ ${n-}${local_archive_size} MB${g-} ] to respect your settings."
		dna-echo -m "Purged all backups older than the most recent: | ${y-}${counter}${n-} |."
		dna-echo -m "Continuing..."

	fi

	if [ "${backup_total_size_estimate}" -gt "${free_disk_space}" ]
	then

		dna-echo -e "Estimated backup size: [ ${n-}${backup_total_size_estimate} MB${r-} ] larger than available disk space: [ ${n-}${free_disk_space} MB${r-} ]."
		dna-echo -m "Now purging old backups while respecting your specified number of minimum backups to keep..."

		error_description="to free enough disk space for the next backup"

		counter="${max_local_backups}"

		while [ "${backup_total_size_estimate}" -gt "${free_disk_space}" ]
		do

			dna-backup_purge_loop

		done

		dna-echo -s "Enough free space: [ ${n-}${free_disk_space} MB${r-} ] now available for new backup."
		dna-echo -m "Purged all backups older than the most recent: | ${y-}${counter}${n-} |."
		dna-echo -m "Continuing..."

	fi

}

dna-backup_purge_loop() {

	if [ "${local_archive_items}" -gt "${min_local_backups}" ]
	then

		counter=$(("${counter}" - 1))

		### prevent infinite loops in case of rm failure.

		if [ $counter = -1 ]
		then
			echo "${r-}${b-}Infinite loop error caught. Exiting...${b-}"
			exit 1
		fi

		if [ $local_archive_items -gt $counter ]
		then
			tail_number=$(( $counter + 1 ))
			( cd "$backup_local_storage_path/archive" && ls -t | tail -n +"$tail_number" | xargs -d '\n' rm )
		fi

		dna-backup_update_storage_info

	else

		if [ $counter = 0 ]
		then

			dna-echo -e "Even though there are no backups currently archived in local storage, meeting your setting of minimum backups to keep at | 0 |, there still isn't enough storage on the local storage's [$backup_local_storage_path] underlying volume."
			echo
			echo "${b-}Please inspect your disk for any files you don't need, or consider using an[other] external location by re-running the installer and choosing | custom | for the | backup_local_storage_location | setting.${x-}"
			echo

		else

			echo "${r-}${b-}The specified number of minimum backups to keep [$min_local_backups] is too high $error_description.${x-}"
			echo
			echo "${b-}Lower this figure by re-running the install and lowering this figure during configuration or make more space available on this machine.${x-}"
			echo

		fi

		if [ -d "$backup_local_storage_path/archive/old" ]
		then

			old_dir_size="$(du -sm "$backup_local_storage_path/archive/old" | xargs | sed -e "s|"${backup_local_storage_path}/archive/old"||g" | xargs)"

			echo "${b-}Found | $backup_local_storage_path/archive/old | directory weighing | $old_dir_size |.${x-}"
			echo
			echo "${b-}Consider freeing up space by removing these old backups if unneeded.${x-}"
			echo

		fi

		dna-exit

	fi

}

dna-backup_create_dirs() {

	if [ "${1:-null}" = "backup" ]
	then

		backup_name="${script_name}-${now}"

		backup_archive_dir="${backup_local_storage_path}/archive"
		backup_latest_dir="${backup_local_storage_path}/latest"
		backup_tmp_dir="${backup_local_storage_path}/tmp"

		backup_tmp_name_dir="${backup_local_storage_path}/tmp/${backup_name}"
		backup_tmp_name_conf_dir="${backup_tmp_name_dir}/conf"
		backup_tmp_name_data_dir="${backup_tmp_name_dir}/data"

		mkdir -p "${backup_archive_dir}"
		mkdir -p "${backup_latest_dir}"
		mkdir -p "${backup_tmp_dir}"

		mkdir -p "${backup_tmp_name_data_dir}"

	fi

	mkdir -p "${backup_tmp_name_dir}"

}

dna-backup_purge_dirs() {

	### purge temp and create directories.

	if [ -d "${backup_local_storage_path}/tmp" ]
	then
		rm -r "${backup_local_storage_path:?}/tmp"
	fi

	if [ -d "${backup_local_storage_path}/latest" ]
	then
		rm -r "${backup_local_storage_path:?}/latest"
	fi

	if [ -d "$backup_local_storage_path/restores" ]
	then
		rm -r "${backup_local_storage_path:?}/restores"
	fi

}

dna-backup_purge_incomplete_archives() {

	if [ -d "${backup_local_storage_path}/archive" ]
	then
		find "$backup_local_storage_path/archive" -type f -name '*.incomplete' -delete
	fi

}

dna-backup_check_set_lockfile() {

	### check for lockfile to avoid multiple simultaneous backups.

	if [ -f "/tmp/${project_name}-backup-running-lockfile" ]
	then

	    dna-echo -e "It appears a ${project_name} backup is already running, perhaps an automated daily one, or perhaps the last one was interrupted."
	    dna-echo -m "If this *is* an automated daily one, please check that you're not running a manual one or that the last run was interrupted."
	    dna-echo -m "Running multiple simultaneous backups is absolutely not supported and will make both fail."

		if [ "${interactive}" = "y" ]
	    then
	        dna-ask_for_boolean -d "n" -q "If you're certain that another backup is NOT running, would you like to ignore the lockfile and continue?"
	        if [ "${boolean_output}" = "y" ]
	        then
	            dna-echo -m "Ok, continuing anyway..."
	            export lockfile_set="/tmp/${project_name}-backup-running-lockfile"
	        else
	            dna-echo -m "Ok, aborting..."
	            dna-exit
	        fi

	    else

	        dna-echo -m "If you're certain that another backup is NOT running, run this script manually and select to ignore the lockfile and continue when prompted."
	        dna-echo -m "Alternatively, you can also log into this machine and | ${o-}rm /tmp/${project_name}-backup-running-lockfile${n-} |."
	        dna-echo -e "Aborting backup for now."
	        dna-exit

	    fi

	else

	    ### set backup lockfile.

	    export lockfile_set="/tmp/${project_name}-backup-running-lockfile"
	    touch "${lockfile_set}"

	fi

}

dna-calculate_backup_paths_size() {

	### fetch sizes for the directories that have the most impactful sizes that
	### will affect backups [such as '/var/www/' for nginx-related projects].
	### all sizes in MB.

	backup_paths_size_estimate=0

	for this_backup_path in "${!backup_paths_default_array[@]}"
	do

		if [ ${backup_paths_default_array[$this_backup_path]} = "existing" ]
		then

			### this is an existing backup path, calculate its size and add it
			### to the total.

			this_backup_path_size="$(du -sm ${this_backup_path} | cut -f1)"
			backup_paths_size_estimate="$((${backup_paths_size_estimate} + ${this_backup_path_size}))"

		else

			### this is a generated backup path, synthia will take care of
			### calculating its size afterwards.

			true

		fi

	done

}

dna-backup_create_additional_paths_dirs() {

	for this_backup_path in "${!backup_paths_default_array[@]}"
	do

		if [ ${backup_paths_default_array[$this_backup_path]} = "generated" ]
		then

			mkdir -p "${tmp_project_backup_dir}/${this_backup_path}"

		fi

	done

}

dna-backup_locally_conf_dir() {

	rsync -aAXxL "${conf_dir}/" "${backup_tmp_name_conf_dir}"

}

dna-backup_locally_data_backup_paths() {

	for this_backup_path in "${!backup_paths_default_array[@]}"
	do

		# this_backup_path_name="$(echo ${this_backup_path} | sed "s|/|_|g" | sed "s|^_||g" | sed "s|-$||g")"

		if [ ${backup_paths_default_array[$this_backup_path]} = "existing" ]
		then

			rsync -aAXxRL "${this_backup_path}/" "${backup_tmp_name_data_dir}/"

		else

			mkdir -p "${backup_tmp_name_data_dir}/other/"
			rsync -aAXxL "${tmp_project_backup_dir}/${this_backup_path}/" "${backup_tmp_name_data_dir}/other/${this_backup_path}/"

		fi

	done

}

dna-archive_local_backup() {

	dna-echo_operation -h "archiving backup and storing it in: | ${l-}${backup_archive_dir}${n-} |."

	cd "${backup_tmp_dir}"

    if [ -z "${backup_last_before_restore-}" ]
	then

    	## tar [and - if chosen - bzip2] this backup archive.

		if [ "$backup_compression_type" = "bz2" ]
		then

			output_file_name="${backup_name}.tar.bz2"
			output_file_path="${backup_local_storage_path}/archive/${output_file_name}"

	    	tar cSf - ${backup_name} -P | pv -s $(du -sb ${backup_name} | awk '{print $1}') | bzip2 > "${output_file_path}.incomplete"

		else

			output_file_name="${backup_name}.tar"
			output_file_path="${backup_local_storage_path}/archive/${output_file_name}"

			tar cSf - ${backup_name} -P | pv -s $(du -sb ${backup_name} | awk '{print $1}') > "${output_file_path}.incomplete"

		fi

    else

    ## tar [and - if chosen - bzip2] this backup archive.
		## give local backup a custom name so that it's clear it's the last one
		## before a restore.

		if [ "${backup_compression_type}" = "bz2" ]
		then

			output_file_name="${backup_name}-last-backup-before-${now}-restore.tar.bz2"
			output_file_path="${backup_local_storage_path}/archive/${output_file_name}"

	    	tar cSf - ${backup_name} -P | pv -s $(du -sb ${backup_name} | awk '{print $1}') | bzip2 > "${output_file_path}.incomplete"

		else

			output_file_name="${backup_name}-last-backup-before-${now}-restore.tar"
			output_file_path="${backup_local_storage_path}/archive/${output_file_name}"

			tar cSf - ${backup_name} -P | pv -s $(du -sb ${backup_name} | awk '{print $1}')> "${output_file_path}.incomplete"

		fi

    fi

	cd -

	echo

	mv "${output_file_path}.incomplete" "${output_file_path}"

	dna-echo_operation -t

}

dna-backup_check_install_complete() {

	if [ -z ${skip_install_complete_check-} ]
	then

		### abort if the current installation was never completed.

		dna-check_install_complete

		if [ "${install_complete}" = "n" ]
		then

			dna-echo -e "It appears ${project_name} is not currently installed or there is an incomplete installation on this machine."
	        dna-echo -m "This backup script only works on a fully installed ${project_name} instance."
	        dna-echo -m "Please finish installing ${project_name} before running this script."
			dna-exit

		fi

	fi

}

dna-backup_locally() {

	if [ -z "${backup_skip_install_complete_check-}" ]
	then

		dna-backup_check_install_complete

	fi

	dna-backup_locally_conf_dir

 	synthia-backup_locally

 	dna-archive_local_backup

	if [ -n "${backup_last_before_restore-}" ]
	then

		### if not restoring a previous state of this same installation, then
		### move the backups directory to an "old" named one.

		if [ "${restore_type}" = "here" ]
		then

			dna-echo -m "Last backup before restore archived to directory: | ${l-}${backup_local_storage_path}/archive${n-} |."

		else

			mkdir -p "${backup_local_storage_path}/old"

			mv "${backup_local_storage_path}/archive" "${backup_local_storage_path}/old/archive-old-before-restore-on-${now}"

			if [ -d "${duplicity_log_dir}/backup" ]
			then
				mkdir -p "${duplicity_log_dir}/old"
				mv "${duplicity_log_dir}/backup/" "${duplicity_log_dir}/old/backup-old-before-restore-on-${now}"
			fi

			dna-echo -m "Last backup before restore archived to directory: | ${l-}${backup_local_storage_path}/old/archive-old-before-restore-on-${now}${n-} |."

		fi

	fi

}

dna-backup() {

	### initiate.

	dna-backup_purge_dirs

	dna-backup_create_dirs backup

	if [ "${backup_locally_mode_default}" = "enabled" ]
	then

		dna-backup_purge_incomplete_archives

		dna-backup_update_storage_info

		dna-backup_purge_backups

	fi

	### initiate s3 and test restore.

	if [ "$backup_archival_location" = "s3" ] && [ -z "${backup_locally_only-}" ]
	then

		if [ "${backup_test_restore_mode_default}" = "enabled" ]
		then

		    dna-restore_reinstate_s3 test

		fi

	    dna-backup_purge_dirs

	    dna-backup_create_dirs backup

	fi

	### perform pre-backup operations.

	synthia-backup_pre_operations

	### backup locally.

	if [ "${backup_locally_mode_default}" = "enabled" ] && [ -z "${backup_s3_only-}" ]
	then

		dna-backup_locally

		### perform post-backup operations.

		synthia-backup_post_operations

	fi

	### backup to s3.

	if [ "${backup_archival_location}" = "s3" ]
	then

	    if [ "${s3_restore_test_failed-null}" = "y" ]
	    then

	        dna-echo -e "Skipping S3 backup because of a previous test restore failure."

	        rm -r "${backup_tmp_dir}"

	    else

			if [ "${backup_locally_mode_default}" = "enabled" ]
			then

		    	mv "${backup_tmp_dir}"/* "${backup_latest_dir}"

			fi

	    	############################################################################

	    	dna-backup_to_s3

			if [ "${backup_locally_mode_default}" = "disabled" ]
			then

				### perform post-backup operations.

				synthia-backup_post_operations

			fi

	    fi

	else

		if [ "${backup_locally_mode_default}" = "disabled" ]
		then

			dna-echo -e "Local backups disabled and S3 backups not enabled. Not performing any backups."

			### perform post-backup operations.

			synthia-backup_post_operations

		fi

		rm -r "$backup_tmp_dir"

	fi

}

dna-backup_cleanup() {

	if [ -d "$backup_local_storage_path/tmp" ]
	then
		rm -r "${backup_local_storage_path:?}/tmp"
	fi

	dna-backup_purge_dirs

	if [ -f "/tmp/${project_name}-backup-running-lockfile" ]
	then
	    rm "/tmp/${project_name}-backup-running-lockfile"
	fi

	if [ "${s3_restore_test_failed-null}" = "y" ]
	then
	    dna-exit
	fi

	dna-echo -s "Backup complete!"

}

dna-last_local_backup() {

    dna-echo "Now performing a last backup [locally - no S3 of course] this machine's currently running $project_name installation just in case..."

}

dna-restore_rollback() {

	if [ ! -d "$backup_local_storage_path/archive" ]
	then
		echo "${r-}${b-}Local backups directory [$backup_local_storage_path/archive] not found.${x-}"
		echo
		echo "${b-}It's possible you've already partially run this restore script choosing the | reinstate | option, or that this machine never successfully ran a backup.${x-}"
		echo
		echo "${b-}Check your $install_dir for a directory called | backups(-[something]) | and if you find something rename the most recently datestamped directory to | backups | ."
		echo
		echo "${b-}Exiting...${x-}"
		echo
		exit 1
	fi

	count="$(ls -1 $backup_local_storage_path/archive/*.tar* 2>/dev/null | wc -l)"
	if [ $count = 0 ]
	then
		echo "${r-}${b-}No backup archives found in local backups directory [$backup_local_storage_path/archive].${x-}"
		echo
		echo "${b-}It's possible you've already partially run this restore script choosing the | reinstate | option, or that this machine never successfully ran a backup.${x-}"
		echo
		echo "${b-}Check your $install_dir for a directory called | backups(-[something]) | and if you find something rename the most recently datestamped directory to | backups | ."
		echo
		echo "${b-}Exiting...${x-}"
		echo
		exit 1
	fi

	echo "${b-}These are the backup dates available for restore:${x-}"
	echo
	ls -1 "$backup_local_storage_path/archive" | sed -e "s/${project_name}-backup-//g" | sed -e 's/.tar//g' | sed -e 's/.bz2//g'
	echo
	read -rp "${b-}[press enter to continue...]${x-}"
	clear

	choice="${b-}Now choose the file you'd like to restore: ${x-}"
	echo "$choice"
	echo

	set +u

	cd "$backup_local_storage_path/archive"
	unset options i
	while IFS= read -r -d $'\n' f; do
		options[i++]="$f"
	done < <(find ./ -maxdepth 1 -type f -name "*.tar*" | sort -r )
	IFS=$' \t\n'

	set -u

	accept=n
	until [ $accept = "y" ]
	do

		select sel_backup_file in "${options[@]}" "exit"
		do
			echo
			case $sel_backup_file in
				*.tar)
				echo "${b-}Backup file $sel_backup_file selected.${x-}"
				break
				;;
				"exit")
				echo "${b-}Exiting...${x-}"
				echo
				exit
				;;
				*)
				echo "${r-}${b-}Invalid option. Retry...${x-}"
				echo
				;;
			esac
		done
		echo

		valid=n
		until [ $valid = "y" ]
		do
			read -n 1 -rp "${b-}Is this the correct file?${x-} (${b-}Y${x-}[es]/${b-}n${x-}[o]/${b-}e${x-}[xit]) " answer;
			case $answer in
				"")
				echo
				valid=y
				accept=y
				;;
				y)
				echo -e "\\n"
				valid=y
				accept=y
				;;
				n)
				echo -e "\\n"
				echo "${b-}No problem, please select your desired file again now...${x-}"
				echo
				valid=y
				accept=n
				;;
				e)
				echo -e "\\n"
				echo "${b-}Exiting...${x-}"
				echo
				exit
				;;
				*)
				echo -e "\\n"
				echo "${b-}Invalid option. Retry...${x-}"
				echo
				valid=n
				accept=n
				;;
			esac
		done

	done

	mkdir -p "$backup_local_storage_path/restores/local/"

	if [ ${sel_backup_file: -4} == ".bz2" ]
	then
		tar -xvjf "$sel_backup_file" -C "$backup_local_storage_path/restores/local/"
	else
		tar -xvf "$sel_backup_file" -C "$backup_local_storage_path/restores/local/"
	fi

	echo

}

dna-restore_reinstate_standalone() {

	dna-echo -m "Ok, restoring from a standalone ${project_name} backup file."

	reinstate_standalone_basedir="/root/${project_name}-restore"

	mkdir -p "${reinstate_standalone_basedir}"

	dna-ask_for_boolean -d y -q "Do you have a file called | $project_name-backup-[date].tar[.bz2] | [or similar]? [Y/n]"

	if [ "${boolean_output}" = "y" ]
	then

		validate_input() {

			if [ -f "${reinstate_standalone_file_chosen}" ]
			then
				valid="y"
			else
				dna-echo -e "The specified file does not exists."
				valid="n"
			fi

		}

        dna-set_value -d "Ok, specify the path to that file now:" -v "y"

		reinstate_standalone_file_chosen="${value}"

		dna-echo -s "Backup file ${reinstate_standalone_file_chosen} selected."

		if [ ${reinstate_standalone_file_chosen: -4} == ".bz2" ]
		then
			tar -xvjf "${reinstate_standalone_file_chosen}" -C "${reinstate_standalone_basedir}"
		else
			tar -xvf "${reinstate_standalone_file_chosen}" -C "${reinstate_standalone_basedir}"
		fi

		reinstate_standalone_subdir=("${reinstate_standalone_basedir}"*/)

		reinstate_standalone_subdir_name="$(echo "${reinstate_standalone_subdir}" | sed "s|${reinstate_standalone_basedir}/||" | tr -d '/')"

		mv "${reinstate_standalone_basedir}/${reinstate_standalone_subdir_name}"/* "${reinstate_standalone_basedir}/"
		rm -r "${reinstate_standalone_basedir}/${reinstate_standalone_subdir_name}"

	else

		dna-echo -m "Ok, no problem. Make sure you populate the: | ${l-}${reinstate_standalone_basedir${n-}} | directory with the following files/directories from your standalone backup:"

		restore_from_standalone_content_description

		dna-echo -e "If you don't correctly place all the above files/directories, the restore will not work correctly [you will be alerted if something is wrong further along this script]."

		dna-echo -m "As soon as you're done moving these items into place..."

		dna-press_to_continue

		if [ "${validate_standalone_restore_content}" = "y" ]
		then
			restore_from_standalone_content_validation
		fi

	fi

}

dna-backup_generate_duplicity_includes() {

	> "${tmp_project_dir}/duplicity-include"

	for this_backup_path in "${!backup_paths_default_array[@]}"
	do

		echo "${this_backup_path}" >> "${tmp_project_dir}/duplicity-include"

	done

}

dna-duplicity_source_vars() {

	### export some ENV variables so you don't have to type anything.

	dna-get_hostname

	export HOST="$(hostname)"
	export DATE="$(date +%Y-%m-%d)"
	export MAILADDR="${admin_mail-}"
	export TODAY="$(date +%d%m%Y)"

	export AWS_ACCESS_KEY_ID="${s3_access_key_id}"
	export AWS_SECRET_ACCESS_KEY="${s3_secret_access_key}"
	export PASSPHRASE="${backups_passphrase}"

}

dna-duplicity_unset_vars() {

	### reset the env variables. don't need them sitting around.

	unset HOST DATE MAILADDR TODAY AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY PASSPHRASE

}

dna-duplicity_loop() {

	### raise ulimit for open files.

	if ! grep -q "fs.file-max = 2097152" "/etc/sysctl.conf"
	then
		echo "fs.file-max = 2097152" >> "/etc/sysctl.conf"
	fi

	standard_ulimit_n="$(ulimit -n)"
	ulimit -n "524288"

	### your GPG key.

	# GPG_KEY= # Insert GPG key here if using GPG

	### the S3 destination followed by bucket name.

	dna-get_hostname

	DEST="s3://${s3_endpoint}/${s3_bucket_name}/${project_name}/${hostname}/latest/"

	dna-duplicity_source_vars

	if [ "${1:-null}" = "backup" ]
	then
		duplicity_mode="backup"
	else
		duplicity_mode="restore"
	fi

	duplicity_base_dir="${logs_dir}/${project_name}-duplicity"
	duplicity_log_dir="${duplicity_base_dir}/${duplicity_mode}"

	### set up some variables for logging.

	LOGFILE="${duplicity_log_dir}/${duplicity_mode}.log"
	DAILYLOGFILE="${duplicity_log_dir}/${duplicity_mode}.daily.log"
	FULLBACKLOGFILE="${duplicity_log_dir}/${duplicity_mode}.full.log"

	is_running=$(ps -ef | grep duplicity  | grep python | wc -l)

	if [ ! -d "${duplicity_log_dir}" ]
	then
		mkdir -p "${duplicity_log_dir}"
	fi

	if [ ! -f "${FULLBACKLOGFILE}" ]
	then
		touch "${FULLBACKLOGFILE}"
	fi

	if [ "${is_running}" -eq 0 ]
	then

		### clear the old daily log file.

		cat /dev/null > ${DAILYLOGFILE}

		### trace function for logging, don't change this.

		trace() {
			stamp=$(date +%Y-%m-%d_%H:%M:%S)
			echo "$stamp: $*" >> ${DAILYLOGFILE}
		}

		if [ "${1:-null}" = "backup" ]
		then

			### set the source for the backup.
			### use / for full system backup [not the case here].

			if [ "${backup_locally_mode_default}" = "enabled" ]
			then

				SOURCE="--include ${backup_local_storage_path}/latest/"

			else

				synthia-backup_generate_additional_paths

				dna-backup_generate_duplicity_includes

				SOURCE="--include-filelist ${tmp_project_dir}/duplicity-include"

			fi

		fi

		FULL=
		tail -1 "${FULLBACKLOGFILE}" | grep "${TODAY}" > /dev/null || true
		if [ $? -ne 0 -a "$(date +%d)" -eq 1 ]
		then
			FULL=full
		fi;

		trace "Backup for local filesystem started"

		set +e

		if [ "${1:-null}" = "backup" ]
		then

			### how long to keep backups for.

			OLDER_THAN="$duplicity_min_history"

			trace "... removing old backups"

			duplicity remove-older-than "${OLDER_THAN}" "${DEST}" >> "${DAILYLOGFILE}" 2>&1  || true

		fi

		trace "... backing up filesystem"

		#    duplicity \
		#        ${FULL} \
		#        --encrypt-key=${GPG_KEY} \
		#        --sign-key=${GPG_KEY} \
		#        --include=/var/rsnap-mysql \
		#        --include=/var/www \
		#        --include=/etc \
		#        --exclude=/** \
		#        ${SOURCE} ${DEST} >> ${DAILYLOGFILE} 2>&1

		if [ "${1:-null}" = "backup" ]
		then

			### insert '--encrypt-key' and '--sign-key' after '${full}' if using
			### gpg.

			duplicity --progress --allow-source-mismatch ${FULL} / ${SOURCE} --exclude '**' "${DEST}"

		elif [ "${1:-null}" = "restore" ]
		then

			duplicity "${DEST}" "$backup_local_storage_path/restores/s3/" 2>&1 | tee "$backup_local_storage_path/tmp/duplicity-log"

		fi

		set -e

		trace "Backup for local filesystem complete"
		trace "------------------------------------"

		if [ "${1:-null}" = "backup" ]
		then

			### send the daily log file by email.

			BACKUPSTATUS=$(cat "$DAILYLOGFILE" | grep -i error | wc -l)

			if [ "${BACKUPSTATUS}" != "0" ]
			then

				cat "$DAILYLOGFILE" | mail -aFrom:"$script_name@$HOST" -s "ERROR in $script_name backup for $HOST on $DATE" $MAILADDR

			elif [ "${FULL}" = "full" ]
			then

				echo "$(date +%d%m%Y_%T) Full Back Done" >> "${FULLBACKLOGFILE}"

			fi

		fi

		### append the daily log file to the main log file.

		cat "${DAILYLOGFILE}" >> "${LOGFILE}"

		dna-duplicity_unset_vars

	else

		dna-echo -e "It appears duplicity is already running on this server."
		dna-echo -m "If you've manually overridden a lockfile check at the beginning of this script's execution, you should consider that it's likely another backup is occurring."
		dna-echo -m "If you're sure this is not the case, reboot the server and run this script again or see what happens at the next automated run."
		dna-exit

	fi

	### reset ulimit for open files.

	ulimit -Sn "${standard_ulimit_n}"

}

dna-backup_to_s3() {

	dna-echo_operation -h "backing up to S3"

    if [ -f "${conf_backups_s3_dir}/block_s3_backups" ]
    then
        dna-echo -e "Not performing backup as: | ${n-}${conf_backups_s3_dir}/block_s3_backups${r-} | file found."
        dna-echo -m "This should indicate that during installation you specified your intent to use this machine as a restore for a previous instance of ${project_name} backed up on S3."
        dna-echo -m "Ff this is the case, simply run the restore script right away. If it is not, and you want to use this machine for a new installation and OVERWRITE all backups currently on S3, erase this file."
        dna-echo -e "No backups will run on this instance until you perform the restore script or remove the file to specify your intent to use this machine as it is for a new installation."
		dna-exit
    fi

	dna-duplicity_loop backup

	### also upload today's full backup file to S3 if s3_monthly_uploads=y
	### [only if this is NOT a manual run].

	today_day_of_month="$(date +%-d)"

	if [ ${today_day_of_month} = "1" ] && [ ${interactive} = "n" ] && [ "${backup_locally_mode_default}" = "enabled" ]
	then

		dna-echo -m "Also performing duplicity-independent first-of-the-month upload of: | ${l-}"${output_file_name}"${n-} | to S3 as well."

		encrypt() {
			echo "$backups_passphrase" | gpg --output  "$backup_local_storage_path/tmp/$@.gpg" --passphrase-fd 0 --batch --yes --symmetric -z 9 --require-secmem --cipher-algo AES256 --s2k-cipher-algo AES256 --s2k-digest-algo SHA512 --s2k-mode 3 --s2k-count 65000000 --compress-algo BZIP2 $@
		}

		decrypt() {
			gpg $@
		}

		putS3() {
			path=$1
			file=$2
			aws_path=$3
			bucket="$s3_bucket_name"
			date=$(date +"%a, %d %b %Y %T %z")
			acl="x-amz-acl:public-read"
			content_type='application/x-compressed-tar'
			string="PUT\n\n$content_type\n$date\n$acl\n/$bucket$aws_path$file"
			signature=$(echo -en "${string}" | openssl sha1 -hmac "${s3_secret_access_key}" -binary | base64)
			curl -X PUT -T "$path/$file" \
			-H "Host: $bucket.$s3_endpoint" \
			-H "Date: $date" \
			-H "Content-Type: $content_type" \
			-H "$acl" \
			-H "Authorization: AWS ${s3_access_key_id}:$signature" \
			"https://${bucket}.${s3_endpoint}${aws_path}${file}"
		}

		( cd "${backup_local_storage_path}/archive/" && encrypt "${output_file_name}" )

		putS3 "${backup_local_storage_path}/tmp/" "${output_file_name}.gpg" "/${project_name}/archive/" 2> /dev/null

	fi

}

dna-restore_reinstate_s3() {

	if [ "${1:-null}" = "test" ]
	then

		dna-echo -m "Testing restore from S3 to ${backup_local_storage_path}/restores/s3/ to ensure existing backups integrity and passphrase match."

	else

		dna-echo -m "Restoring from S3 to ${backup_local_storage_path}/restores/s3/."

	fi

	dna-echo -m "This is going to take some time and will NOT output any progress information until it's done."

	dna-duplicity_loop restore

	if grep -q "No backup chains found" "${backup_local_storage_path}/tmp/duplicity-log"
	then

		if [ "${1:-null}" = "test" ]
		then

			### this is the first backup, all is good.

			dna-echo -m "First S3 backup detected. Skipping restore test."

		else

			### no backups found on server, something's wrong.

			dna-echo -e "Restore from S3 failed."
			dna-echo -m "It appears there are no backups on the S3 server under the path: | ${y-}${project_name}/latest${n-} | [check the above output for messages like: | ${r-}No backup chains found${n-} |]."
			dna-exit

		fi

	else

		if grep -q "gpg: decryption failed: bad key" "${backup_local_storage_path}/tmp/duplicity-log" || [ ! -d "${backup_local_storage_path}/restores/s3/" ]
		then

			if [ "${1:-null}" = "test" ]
			then

				dna-echo -e "Testing restore from S3 failed."
				dna-echo -m "Is appears this instance of ${project_name} has on file an incorrect S3 encryption passphrase [check the above output for messages like: | ${r-}gpg: decryption failed: bad key${n-} |]."
				dna-echo -m "If this is the case, you've likely changed your backups encryption passphrase on this machine between your last backup and this one."
				dna-echo -m "This would cause S3 backups to be encrypted with two or more encryption keys at the same time, which would render them unusable in the future should you ever need them."
				dna-echo -m "Edit the file: | ${y-}${conf_backups_s3_dir}/backups_passphrase${n-} | and set once again your previous encryption passphrase, then re-run this script."
				dna-echo -m "If you have lost your previous encryption passphrase, delete all your S3 backups and re-run this script to make an entirely new backup set encrypted solely with the currently specified passphrase."
				dna-echo -e "Aborting S3 backup because of connection / integrity check failure."

				if [ ${interactive} = "y" ]
				then

					dna-ask_for_boolean -d "y" -q "Would you like to continue with a local-only backup anyway?"

			        if [ "${boolean_output}" = "y" ]
					then

						dna-echo -m "Ok, continuing with local-only backup."
						export s3_restore_test_failed="y"

					else

						dna-echo -m "Ok, aborting."
						dna-exit

					fi

				else

					dna-echo -m "Continuing with local-only backup anyway."
					export s3_restore_test_failed=y

				fi

			else

				dna-echo -e "Restore from S3 failed."
				dna-echo -m "Is appears this instance of ${project_name} has on file an incorrect S3 encryption passphrase [check the above output for messages like: | ${r-}gpg: decryption failed: bad key${n-} |]."
				dna-echo -m "Edit the file: | ${y-}${conf_backups_s3_dir}/backups_passphrase${n-} | and replace the currently specified passphrase with the old one from your previous machine, then re-run this script."
				dna-echo -m "If you have lost your previous encryption passphrase, you've also lost access to your backups."
				dna-exit

			fi

		else

			echo

			if [ "${1:-null}" = "test" ]
			then

				dna-echo -s "S3 Restore test succeded. Proceeding with S3 backup."

			else

				dna-echo -s "Restore succeded."

			fi

		fi

	fi

}

dna-restore() {

	### evaluate arguments.

	### ########################################################################

	while getopts ":s" arguments
	do
		case $arguments in
			s)	restore_reinstate_source="s3"
				restore_skip_questions="y"
				restore_type="reinstate"
				;;
			\?)	dna-echo -e "Invalid option | ${n-}-${OPTARG}${r-} | for function | ${n-}${FUNCNAME[0]}${r-} |."
                dna-exit
                ;;
		esac
	done
    OPTIND=1

	### ########################################################################

	### initiate.

	if [ -n ${restore_skip_questions-} ]
	then

		dna-echo -m "A restore can be performed in two ways."
		dna-echo -m "A] by rolling back the running instance of ${project_name} on this machine from a backup file generated and archived locally in the backups directory [rollback]"
		dna-echo -m "B] by fetching and unpacking a backup archive stored remotely on S3 or provided in a standalone fashion by you during the restore phase [reinstate]"

		dna-read_input -p "Are you trying to restore by performing a rollback or a reinstate? [b/s]"

		case $read_input_answer in
		    b)	export restore_type="rollback"
				;;
		    s)	export restore_type="reinstate"
				;;
		    \?)	exit
				;;
		esac

	    if [ "${restore_type}" = "rollback" ]
	    then

	    	dna-restore_rollback

	    elif [ "${restore_type}" = "reinstate" ]
		then

			dna-read_input -p "Are you trying to reinstate a backup archive stored on S3 or a standalone file you have from elsewhere? [3/a]"

			case $read_input_answer in
			    3)	export restore_reinstate_source="s3"
					;;
			    a)	export restore_reinstate_source="standalone"
					;;
			    \?)	exit
					;;
			esac

			if [ "${backup_archival_location-null}" = "s3" ]
	    	then

				dna-echo -m "You've previously setup an S3 file storage server connection for backups on this machine."
				dna-echo -m "The current S3 connection is set to bucket: | ${y-}${s3s3_bucket_name}${n-} | on endpoint: | ${o-}${s3s3_endpoint}${n-} |."

				dna-ask_for_boolean -d y -q "Would you like to use this existing S3 connection for the reinstate?"

				if [ "${boolean_output}" = "y" ]
				then

					dna-echo -m "Ok, using the existing S3 connection for the reinstate."

				else

					dna-echo -m "Ok, setting up the new S3 connection now."

					dna-setup_backup_restore_s3

				fi

			else

				dna-echo -m "There is no S3 file storage server connection present for backups on this machine."

				dna-ask_for_boolean -d y -q "Would you like to setup a connection to the S3 endpoint where the backup archive you intend to reinstate is stored now?"

				if [ "${boolean_output}" = "y" ]
				then

					dna-echo -m "Ok, setting up the new S3 connection now."

					dna-setup_backup_restore_s3

				else

					dna-echo -m "Ok, falling back to a standalone reinstate from a manually provided file."

					export restore_reinstate_source="standalone"

				fi

	    	fi

			if [ $restore_reinstate_source = "s3" ]
			then

				dna-restore_reinstate_s3

			else

				dna-restore_reinstate_standalone

				echo

			fi

		fi

	else

		dna-restore_reinstate_s3

	fi

    if [ "${restore_type}" = "rollback" ]
    then
    	export restore_file_name="$(echo "$sel_backup_file" | sed 's|./||g' | sed 's/-last-backup.*-restore//' | sed 's/.tar//g' | sed 's/.bz2//g')"
    	export restore_file_path="$backup_local_storage_path/restores/local/$restore_file_name"
    else
    	if [ $restore_reinstate_source = "s3" ]
    	then
    		export restore_file_path="$backup_local_storage_path/restores/s3"
    	else
    		export restore_file_path="/root/$project_name-restore"
    	fi
    fi

	unset skip_questions

}
